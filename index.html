<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Tree v46 (V45 Particles + V40 Photo Logic)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        .header { color: #ffca28; text-shadow: 0 0 10px rgba(255, 202, 40, 0.5); text-align: center; }
        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; font-size: 1.5rem; }
        .status { color: #ccc; font-size: 0.9rem; margin-top: 5px; text-shadow: 0 0 5px #000; }
        .highlight { color: #ff5555; font-weight: bold; }
        
        .controls { 
            pointer-events: auto; background: rgba(0, 10, 5, 0.85); 
            border: 1px solid #ffca28; padding: 20px; border-radius: 12px; 
            color: #ccc; max-width: 420px; backdrop-filter: blur(8px); 
            align-self: center; text-align: center; 
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            transition: opacity 0.8s ease, transform 0.8s ease;
            opacity: 1; transform: translateY(0);
        }
        .controls.hidden {
            opacity: 0; transform: translateY(20px); pointer-events: none;
        }
        
        .upload-btn { background: linear-gradient(45deg, #d90429, #ef233c); border: 1px solid #ffca28; color: #fff; padding: 12px 24px; cursor: pointer; font-size: 1rem; margin-bottom: 15px; transition: 0.3s; text-transform: uppercase; letter-spacing: 2px; display: inline-block; border-radius: 4px; font-weight: bold; }
        .upload-btn:hover { background: #ffca28; color: #8a0303; box-shadow: 0 0 20px #ffca28; }
        #input-video { display: none; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 20; display: flex; justify-content: center; align-items: center; flex-direction: column; color: #ffca28; transition: opacity 1s; }
        .spinner { width: 50px; height: 50px; border: 4px solid transparent; border-top-color: #ffca28; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #hand-cursor {
            position: absolute; width: 20px; height: 20px; 
            border: 2px solid #ffca28; border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; 
            display: none; z-index: 15; box-shadow: 0 0 10px #ffca28;
            transition: width 0.2s, height 0.2s, background-color 0.2s;
        }
        #hand-cursor.pinching {
            background-color: #ffca28; width: 15px; height: 15px;
        }

        .guide { display: flex; justify-content: space-around; font-size: 0.8rem; margin-top: 15px; opacity: 0.9; }
        .guide-item span { display: block; font-size: 1.4rem; margin-bottom: 8px; }
        .hint { margin-top: 10px; font-size: 0.75rem; color: #aaa; border-top: 1px solid #333; padding-top: 10px;}
    </style>
</head>
<body>
    <div id="loader"><div class="spinner"></div><div>INITIALIZING VISION ENGINE...</div><div style="font-size: 0.8rem; margin-top:10px; color:#777;">ËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ÊùÉÈôê / Please Allow Camera</div></div>
    <div id="hand-cursor"></div>
    <div id="ui-layer">
        <div class="header"><h1>Chroma Galaxy v46</h1><div class="status">STATE: <span id="state-display" class="highlight">TREE</span></div></div>
        <div class="controls" id="controls-panel">
            <label class="upload-btn">Upload Photos<input type="file" id="file-input" multiple accept="image/*" style="display: none;"></label>
            <div class="guide"><div class="guide-item"><span>‚úä</span>Make Tree</div><div class="guide-item"><span>üñêÔ∏è</span>Sphere Galaxy</div><div class="guide-item"><span>üëå</span>Select/Grab</div></div>
            <div class="hint">üëã **Pinch & Release** to spin randomly.<br>Follow the cursor!</div>
        </div>
    </div>
    <video id="input-video"></video>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const CONFIG = {
            // „Äê‰øùÁïôËÆæÁΩÆ„ÄëÂ∞èÁêÉÊï∞Èáè 1500
            particleCount: 1500, 
            treeHeight: 32, treeRadius: 13, 
            scatterRadius: 25, 
            colors: [0xff3333, 0xff3333, 0x55ff55, 0x55ff55, 0xffd700, 0xffffff], 
            cameraZ: 55,
            puffRadius: 3.0,
            spiralLoops: 12
        };
        const STATE = { TREE: 'TREE', SCATTER: 'SCATTER', ZOOM: 'ZOOM' };
        let currentState = STATE.TREE; let targetState = STATE.TREE;
        let isPinching = false; 

        let rotationAngleX = 0; let rotationAngleY = 0; 
        let treeRotationY = 0; 
        
        let targetRotationVelocityX = (Math.random() - 0.5) * 1.5;
        let targetRotationVelocityY = (Math.random() - 0.5) * 1.5;
        let currentRotationVelocityX = 0;
        let currentRotationVelocityY = 0;

        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x050505); scene.fog = new THREE.FogExp2(0x050505, 0.008); 
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 0, CONFIG.cameraZ);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5; 
        document.body.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.85; 
        bloomPass.strength = 1.2; 
        bloomPass.radius = 0.9;   
        const composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

        // --- ÁÅØÂÖâÁ≥ªÁªü ---
        scene.add(new THREE.AmbientLight(0xffffff, 1.5)); 
        const dirLight = new THREE.DirectionalLight(0xffeeb1, 2.0); dirLight.position.set(0, 50, 30); scene.add(dirLight); 
        const plRed = new THREE.PointLight(0xff0000, 12, 100); plRed.position.set(-30, -10, 20); scene.add(plRed); 
        const plGreen = new THREE.PointLight(0x00ff00, 12, 100); plGreen.position.set(30, 10, 20); scene.add(plGreen); 
        const plGold = new THREE.PointLight(0xffd700, 8, 100); plGold.position.set(0, 0, 30); scene.add(plGold); 

        let starMesh; function createStar() { const starGeo = new THREE.OctahedronGeometry(1.5, 0); const starMat = new THREE.MeshStandardMaterial({ color: 0xfffacd, emissive: 0xfffacd, emissiveIntensity: 2.0, roughness: 0.1, metalness: 1.0 }); starMesh = new THREE.Mesh(starGeo, starMat); starMesh.position.set(0, CONFIG.treeHeight / 2 + 1, 0); scene.add(starMesh); } createStar();

        // --- Á≤íÂ≠êÁ≥ªÁªü ---
        const geometrySphere = new THREE.SphereGeometry(0.3, 16, 16); 
        
        const materialMatte = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, roughness: 0.2, metalness: 0.4, emissive: 0x000000, envMapIntensity: 1.0 
        });
        
        const materialMetal = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, roughness: 0.15, metalness: 1.0,  
            emissive: 0xffd700, 
            // „Äê‰øùÁïôËÆæÁΩÆ„ÄëÈáëËâ≤Â∞èÁêÉ‰∫ÆÂ∫¶ 1.3
            emissiveIntensity: 1.3, 
            envMapIntensity: 0.5    
        });

        new RGBELoader()
            // .setPath Âà†Èô§ÊàñÁïôÁ©∫ÔºåÁõ¥Êé•Âä†ËΩΩÂêåÁõÆÂΩïÊñá‰ª∂
            .load( './royal_esplanade_1k.hdr', function ( texture ) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                materialMetal.envMap = texture;
                materialMatte.envMap = texture; 
                materialMetal.needsUpdate = true;
                materialMatte.needsUpdate = true;
            }, undefined, function(err) { console.warn("HDR Error", err); });

        let imeshGold, imeshRed, imeshGreen;
        const particles = []; const dummy = new THREE.Object3D(); 
        let photoMeshes = [];

        function initParticles() {
            const count = CONFIG.particleCount;
            // ‰∏•Ê†º 6:3:1 ÊØî‰æã
            const goldGoal = Math.floor(count * 0.6);
            const redGoal = Math.floor(count * 0.3);  
            const greenGoal = count - goldGoal - redGoal; 

            let goldCount = 0, redCount = 0, greenCount = 0;
            const types = [];
            for(let i=0; i<count; i++) {
                if (i < goldGoal) { types.push('gold'); goldCount++; }
                else if (i < goldGoal + redGoal) { types.push('red'); redCount++; }
                else { types.push('green'); greenCount++; }
            }
            types.sort(() => Math.random() - 0.5);

            imeshGold = new THREE.InstancedMesh(geometrySphere, materialMetal, goldCount);
            imeshRed = new THREE.InstancedMesh(geometrySphere, materialMatte, redCount);
            imeshGreen = new THREE.InstancedMesh(geometrySphere, materialMatte, greenCount);

            imeshGold.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(goldCount * 3), 3);
            imeshRed.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(redCount * 3), 3);
            imeshGreen.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(greenCount * 3), 3);

            imeshGold.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            imeshRed.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            imeshGreen.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            imeshGold.instanceColor.setUsage(THREE.DynamicDrawUsage);
            imeshRed.instanceColor.setUsage(THREE.DynamicDrawUsage);
            imeshGreen.instanceColor.setUsage(THREE.DynamicDrawUsage);

            let goldIdx = 0, redIdx = 0, greenIdx = 0;

            for (let i = 0; i < count; i++) {
                // Âü∫‰∫éËßÜËßâÂπ≥Ë°°ÁöÑÂàÜÂ∏É (1.8 Ê¨°ÊñπÊ†π)
                const v = Math.random(); 
                const progress = Math.pow(v, 1/1.8); 
                const h = (CONFIG.treeHeight / 2) - (progress * CONFIG.treeHeight);
                const rMax = progress * CONFIG.treeRadius;
                const rTree = rMax * Math.sqrt(Math.random()); 
                const thetaTree = Math.random() * Math.PI * 2;

                const rScatter = CONFIG.scatterRadius * Math.cbrt(Math.random()); const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                
                const type = types[i];
                let colorHex;
                
                if (type === 'gold') colorHex = 0xffd700; 
                else if (type === 'red') colorHex = 0xff2222; 
                else colorHex = 0x44ff44; 
                
                const color = new THREE.Color(colorHex);
                let baseScale = 1.0; 

                const twinkleSpeed = 0.5 + Math.random() * 2.0; 
                const twinklePhase = Math.random() * Math.PI * 2; 

                const pData = { 
                    id: i, type: type,
                    pos: new THREE.Vector3(rTree * Math.cos(thetaTree), h, rTree * Math.sin(thetaTree)), 
                    targetTree: new THREE.Vector3(rTree * Math.cos(thetaTree), h, rTree * Math.sin(thetaTree)), 
                    targetScatter: new THREE.Vector3(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi)), 
                    rot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0), 
                    scale: baseScale, 
                    baseColor: color.clone(), 
                    twinkleSpeed: twinkleSpeed,
                    twinklePhase: twinklePhase
                };

                dummy.position.copy(pData.pos); dummy.scale.setScalar(baseScale); dummy.rotation.copy(pData.rot); dummy.updateMatrix();
                
                if (type === 'gold') {
                    imeshGold.setColorAt(goldIdx, color); imeshGold.setMatrixAt(goldIdx++, dummy.matrix);
                } else if (type === 'red') {
                    imeshRed.setColorAt(redIdx, color); imeshRed.setMatrixAt(redIdx++, dummy.matrix);
                } else {
                    imeshGreen.setColorAt(greenIdx, color); imeshGreen.setMatrixAt(greenIdx++, dummy.matrix);
                }
                particles.push(pData);
            }
            scene.add(imeshGold); scene.add(imeshRed); scene.add(imeshGreen);
        }
        initParticles();

        let haloMesh; const haloParticles = [];
        function initRealHalo() {
            // „ÄêÂ¢ûÂº∫„ÄëÁôΩËâ≤ÂÖâÁÇπÊï∞Èáè 3000
            const count = 1000; 
            const geo = new THREE.SphereGeometry(0.1, 8, 8); const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2.5, roughness: 1.0 });
            haloMesh = new THREE.InstancedMesh(geo, mat, count); haloMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            for(let i=0; i<count; i++) {
                const r = CONFIG.scatterRadius * (1.3 + Math.random() * 0.8); 
                const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                const pos = new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                haloParticles.push({ pos: pos, phase: Math.random() * Math.PI * 2, speed: 1 + Math.random() * 2 });
            }
            scene.add(haloMesh);
        }
        initRealHalo();

        let bgStars; 
        function initBackgroundStars() { 
            const starCount = 1000; 
            const bgGeo = new THREE.BufferGeometry(); const positions = []; for(let i=0; i<starCount; i++) { const r = 100 + Math.random() * 100; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1); positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)); } bgGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); bgStars = new THREE.Points(bgGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0 })); scene.add(bgStars); 
        } 
        initBackgroundStars();

        const photoGroup = new THREE.Group(); scene.add(photoGroup); let selectedPhotoIndex = -1; 
        document.getElementById('file-input').addEventListener('change', handleUpload);
        
        // „ÄêÂÖ≥ÈîÆÈÄªËæëËøòÂéü„ÄëV40 ÁöÑÁÖßÁâá‰∏ä‰º†ÈÄªËæë
        function handleUpload(e) {
            const files = e.target.files; if (!files.length) return; photoGroup.clear(); photoMeshes = [];
            const numFiles = files.length; const goldenRatio = (1 + Math.sqrt(5)) / 2; const photoRadiusBase = CONFIG.scatterRadius * 0.9;
            
            // ‰ΩøÁî® V40 ÁöÑÈªÑÈáëËßíËû∫ÊóãÈÄªËæë
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image(); img.src = event.target.result; const texture = new THREE.TextureLoader().load(img.src); 
                    const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, color: 0xbbbbbb }); 
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5, 5), mat); 
                    
                    const i = index; 
                    
                    // V40 ÁöÑËû∫ÊóãÊéíÂàóÈÄªËæë
                    const t = index / numFiles; // 0 Âà∞ 1
                    const hTree = t * (CONFIG.treeHeight / 2) * 0.9; // ‰∏äÂçäÈÉ®ÂàÜ
                    
                    const heightFraction = (hTree + CONFIG.treeHeight / 2) / CONFIG.treeHeight;
                    const rAtHeight = CONFIG.treeRadius * (1 - heightFraction);
                    const rFinal = rAtHeight * 1.05;

                    const thetaSpiral = index * goldenAngle;
                    
                    mesh.userData.originalPos = new THREE.Vector3(rFinal * Math.cos(thetaSpiral), hTree, rFinal * Math.sin(thetaSpiral));
                    
                    // „ÄêÂÖ≥ÈîÆ„ÄëV40 ÁöÑÊï£ÂºÄ‰ΩçÁΩÆÈÄªËæë (Scatter)
                    const yBase = 1 - (i / (numFiles - 1)) * 2; 
                    const radiusAtYBase = Math.sqrt(1 - yBase * yBase); 
                    const thetaBase = 2 * Math.PI * i / goldenRatio;
                    
                    // Á®çÂæÆÊâì‰π±‰∏ÄÁÇπ
                    const y = Math.max(-1, Math.min(1, yBase + (Math.random() - 0.5) * 0.3)); 
                    const theta = thetaBase + (Math.random() - 0.5) * 0.6; 
                    const radiusAtY = Math.sqrt(1 - y * y);
                    const currentR = photoRadiusBase * (0.3 + 0.7 * Math.cbrt(Math.random()));
                    
                    const x = currentR * radiusAtY * Math.cos(theta); 
                    const yPos = currentR * y; 
                    const z = currentR * radiusAtY * Math.sin(theta);
                    
                    mesh.userData.id = index;
                    mesh.userData.scatterPos = new THREE.Vector3(x, yPos, z);
                    mesh.position.copy(mesh.userData.scatterPos); 
                    
                    // „ÄêÂÖ≥ÈîÆ„ÄëV40 ÁöÑÂàùÂßãÊúùÂêëËÆæÁΩÆ
                    mesh.lookAt(0,0,0); 
                    mesh.rotateY(Math.PI); // ËÉåÈù¢ÊúùÂêë‰∏≠ÂøÉ
                    mesh.userData.baseRotation = mesh.rotation.clone();

                    mesh.userData.treeScale = (0.15 + Math.random() * 0.10) * 2.0 * 1.5; 

                    const border = new THREE.Mesh(new THREE.BoxGeometry(5.2, 5.2, 0.1), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 1.0 })); border.position.z = -0.06; border.name = "border"; mesh.add(border); photoGroup.add(mesh); photoMeshes.push(mesh);
                }; reader.readAsDataURL(file);
            }); targetState = STATE.SCATTER;
        }

        const clock = new THREE.Clock(); 
        function updateLogic() {
            const dt = clock.getDelta(); const time = clock.getElapsedTime();
            
            const isReleasingGrab = (currentState === STATE.ZOOM && targetState === STATE.SCATTER);
            const isInitialScatter = (currentState === STATE.TREE && targetState === STATE.SCATTER);

            if (isReleasingGrab || isInitialScatter) {
                targetRotationVelocityX = (Math.random() - 0.5) * 2.0; 
                targetRotationVelocityY = (Math.random() - 0.5) * 2.0;
            }

            currentState = targetState; document.getElementById('state-display').innerText = currentState;
            
            const controls = document.getElementById('controls-panel');
            if (currentState === STATE.SCATTER || currentState === STATE.ZOOM) {
                controls.classList.add('hidden');
            } else {
                controls.classList.remove('hidden');
            }

            if (currentState === STATE.SCATTER) {
                currentRotationVelocityX = THREE.MathUtils.lerp(currentRotationVelocityX, targetRotationVelocityX, dt * 2);
                currentRotationVelocityY = THREE.MathUtils.lerp(currentRotationVelocityY, targetRotationVelocityY, dt * 2);
                rotationAngleX += currentRotationVelocityX * dt;
                rotationAngleY += currentRotationVelocityY * dt;

            } else if (currentState === STATE.TREE) {
                currentRotationVelocityX = THREE.MathUtils.lerp(currentRotationVelocityX, 0, dt * 5);
                currentRotationVelocityY = THREE.MathUtils.lerp(currentRotationVelocityY, 0, dt * 5);
                rotationAngleX = THREE.MathUtils.lerp(rotationAngleX, 0, dt * 2); 
                rotationAngleY = THREE.MathUtils.lerp(rotationAngleY, 0, dt * 2);
                treeRotationY += dt * 0.3; 
            }

            starMesh.rotation.y += dt * 0.5;
            starMesh.position.lerp(new THREE.Vector3(0, currentState === STATE.TREE ? CONFIG.treeHeight / 2 + 1 : CONFIG.treeHeight / 2 + 12 + Math.sin(time)*2, 0), dt * 2); 
            bgStars.material.opacity = THREE.MathUtils.lerp(bgStars.material.opacity, 0.6, dt * 1); 

            const haloScaleBase = currentState === STATE.TREE ? 0 : 1; 
            haloParticles.forEach((hp, i) => {
                dummy.position.copy(hp.pos); const breath = 1 + Math.sin(time * hp.speed + hp.phase) * 0.3;
                dummy.scale.setScalar(haloScaleBase * breath); dummy.lookAt(camera.position); dummy.updateMatrix(); haloMesh.setMatrixAt(i, dummy.matrix);
            });
            haloMesh.instanceMatrix.needsUpdate = true;
            haloMesh.rotation.set(rotationAngleX, rotationAngleY, 0); 

            let goldIdx = 0; let redIdx = 0; let greenIdx = 0;
            const euler = new THREE.Euler(rotationAngleX, rotationAngleY, 0); const rotMatrix = new THREE.Matrix4().makeRotationFromEuler(euler);
            
            const tempColor = new THREE.Color();

            particles.forEach((p, i) => {
                let target = p.targetTree; 
                if (currentState === STATE.TREE) target = p.targetTree.clone().applyAxisAngle(new THREE.Vector3(0,1,0), treeRotationY);
                else if (currentState === STATE.SCATTER || currentState === STATE.ZOOM) target = p.targetScatter.clone().applyMatrix4(rotMatrix);
                
                p.pos.lerp(target, dt * 2.0); dummy.position.copy(p.pos);
                let currentScale = p.scale;
                
                // „Äê‰øùÁïôËÆæÁΩÆ„ÄëÈó™ÁÉÅÈ¢ëÁéá 0.97Ôºå‰∫ÆÂ∫¶ 100.0
                const noise = Math.sin(time * p.twinkleSpeed + p.twinklePhase);
                let brightnessMultiplier = 1.0;
                if (noise > 0.97) { 
                    brightnessMultiplier = 1.0 + (noise - 0.97) * 30.0; 
                }

                tempColor.copy(p.baseColor).multiplyScalar(brightnessMultiplier);

                if (p.type === 'gold') { 
                    const scaleOscillation = currentState === STATE.TREE ? 0.05 : 0.2; 
                    currentScale *= (1 + Math.sin(time * 3 + p.id) * scaleOscillation); 
                }
                dummy.scale.setScalar(currentScale); 
                dummy.rotation.set(p.rot.x + time*0.5, p.rot.y + time*0.3, p.rot.z); 
                dummy.updateMatrix();
                
                if (p.type === 'gold') {
                    imeshGold.setMatrixAt(goldIdx, dummy.matrix);
                    imeshGold.setColorAt(goldIdx, tempColor);
                    goldIdx++;
                } else if (p.type === 'red') {
                    imeshRed.setMatrixAt(redIdx, dummy.matrix);
                    imeshRed.setColorAt(redIdx, tempColor);
                    redIdx++;
                } else {
                    imeshGreen.setMatrixAt(greenIdx, dummy.matrix);
                    imeshGreen.setColorAt(greenIdx, tempColor);
                    greenIdx++;
                }
            });
            
            imeshGold.instanceMatrix.needsUpdate = true; 
            imeshRed.instanceMatrix.needsUpdate = true;
            imeshGreen.instanceMatrix.needsUpdate = true;
            imeshGold.instanceColor.needsUpdate = true; 
            imeshRed.instanceColor.needsUpdate = true;
            imeshGreen.instanceColor.needsUpdate = true;

            let bestCandidate = null; let maxDot = -2.0;
            photoMeshes.forEach(mesh => {
                if (currentState === STATE.TREE) { 
                    let target = mesh.userData.originalPos.clone().applyAxisAngle(new THREE.Vector3(0,1,0), treeRotationY);
                    mesh.position.lerp(target, dt * 2); 
                    
                    // Ê†ëÁä∂ÊÄÅÔºöËÆ©ÁÖßÁâáËÉåÂêë‰∏≠ÂøÉÔºàÂç≥Ê≠£Èù¢ÊúùÂ§ñÔºâ
                    const lookTarget = new THREE.Vector3(0, mesh.position.y, 0);
                    mesh.lookAt(lookTarget);
                    mesh.rotateY(Math.PI); 

                    const s = mesh.userData.treeScale; mesh.scale.lerp(new THREE.Vector3(s, s, s), dt * 3); 
                } else {
                    // „ÄêÂÖ≥ÈîÆËøòÂéü„ÄëV40 ÁöÑÊï£ÂºÄÊõ¥Êñ∞ÈÄªËæë
                    mesh.scale.lerp(new THREE.Vector3(1,1,1), dt * 3); 
                    const basePos = mesh.userData.scatterPos; 
                    // ËøôÈáå‰∏çÁõ¥Êé• applyMatrix4ÔºåËÄåÊòØËÆ©‰ΩçÁΩÆÂõ∫ÂÆöÔºåÈÄöËøá rotateOnWorldAxis ÊóãËΩ¨ mesh Êú¨Ë∫´
                    // ‰ΩÜ V40 ÂéüÊñáÊòØ targetPos = basePos.clone().applyMatrix4(rotMatrix)
                    // ËøôÈáåÁöÑÂÖ≥ÈîÆÊòØ V40 ÁöÑÊóãËΩ¨ÊñπÂºèÔºö
                    // mesh.rotation.copy(mesh.userData.baseRotation) ÈáçÁΩÆÊóãËΩ¨
                    // ÁÑ∂Âêé rotateOnWorldAxis ÊñΩÂä†Êï¥‰ΩìÊóãËΩ¨
                    
                    // ‰∏∫‰∫Ü‰øÆÂ§ç "Âπ≥Ë∫∫" bug Âπ∂ÈÖçÂêà V40 ÈÄªËæëÔºö
                    // V40 ÁöÑ targetPos ÊòØÂ∏¶ÊóãËΩ¨ÁöÑÔºåÊàë‰ª¨Áõ¥Êé•Áî® targetPos
                    const targetPos = basePos.clone().applyMatrix4(rotMatrix);

                    if (currentState === STATE.ZOOM && selectedPhotoIndex === mesh.userData.id) { 
                        mesh.position.lerp(new THREE.Vector3(8, 0, 40), dt * 5); 
                        mesh.lookAt(camera.position); 
                        mesh.scale.lerp(new THREE.Vector3(1.8, 1.8, 1.8), dt * 5); 
                    } else {
                        mesh.position.lerp(targetPos, dt * 3); 
                        
                        // ËøòÂéü V40 ÁöÑÊóãËΩ¨ÈÄªËæëÔºö
                        mesh.rotation.copy(mesh.userData.baseRotation); // ÊÅ¢Â§çÂàùÂßãÊúùÂêë (ËÉåÂØπ‰∏≠ÂøÉ)
                        mesh.rotateOnWorldAxis(new THREE.Vector3(1,0,0), rotationAngleX); // ÊñΩÂä† X ËΩ¥ÂÖ¨ËΩ¨
                        mesh.rotateOnWorldAxis(new THREE.Vector3(0,1,0), rotationAngleY); // ÊñΩÂä† Y ËΩ¥ÂÖ¨ËΩ¨
                        
                        // ËøòÂéü V40 ÁöÑÁÇπÁßØÈÄâÊã©ÈÄªËæë
                        const dir = targetPos.clone().normalize(); 
                        const dot = dir.z; 
                        
                        const border = mesh.getObjectByName("border");
                        if (dot > 0.92 && currentState !== STATE.ZOOM) { 
                            if (dot > maxDot) { maxDot = dot; bestCandidate = mesh; } 
                        } 
                        border.material.emissive.setHex(0xffd700); border.material.emissiveIntensity = 1.0; mesh.scale.lerp(new THREE.Vector3(1.0, 1.0, 1.0), dt * 5);
                    }
                }
            });
            if (currentState === STATE.SCATTER && bestCandidate) { selectedPhotoIndex = bestCandidate.userData.id; const border = bestCandidate.getObjectByName("border"); border.material.emissive.setHex(0xff3333); border.material.emissiveIntensity = 4.0; bestCandidate.scale.lerp(new THREE.Vector3(1.3, 1.3, 1.3), dt * 5); }
            camera.lookAt(0, 0, 0);
        }
        function render() { requestAnimationFrame(render); updateLogic(); composer.render(); } render();

        const videoElement = document.getElementById('input-video');
        const cursor = document.getElementById('hand-cursor');

        function onResults(results) {
            document.getElementById('loader').style.opacity = 0; setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0]; 
                const cx = (landmarks[0].x + landmarks[9].x) / 2; 
                const cy = (landmarks[0].y + landmarks[9].y) / 2;
                
                cursor.style.display = 'block';
                cursor.style.left = (1 - cx) * 100 + '%'; 
                cursor.style.top = cy * 100 + '%';

                const wrist = landmarks[0]; let avgDist = 0; [8, 12, 16, 20].forEach(id => avgDist += Math.sqrt(Math.pow(landmarks[id].x - wrist.x, 2) + Math.pow(landmarks[id].y - wrist.y, 2)));
                const isFist = (avgDist / 4) < 0.22; 
                isPinching = Math.sqrt(Math.pow(landmarks[8].x - landmarks[4].x, 2) + Math.pow(landmarks[8].y - landmarks[4].y, 2)) < 0.10; 
                
                if (isPinching) cursor.classList.add('pinching'); else cursor.classList.remove('pinching');

                if (isFist) targetState = STATE.TREE; else if (isPinching) { if (currentState === STATE.SCATTER || currentState === STATE.ZOOM) targetState = STATE.ZOOM; } else targetState = STATE.SCATTER;
            } else {
                cursor.style.display = 'none';
            }
        }
        const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 }); hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 }); cameraUtils.start();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
