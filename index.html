<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Tree v73 (Clean UI)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        .header { color: #ffca28; text-shadow: 0 0 10px rgba(255, 202, 40, 0.5); text-align: center; }
        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; font-size: 1.5rem; }
        .status { color: #ccc; font-size: 0.9rem; margin-top: 5px; text-shadow: 0 0 5px #000; }
        
        .controls { 
            pointer-events: auto; background: rgba(0, 10, 5, 0.85); 
            border: 1px solid #ffca28; padding: 20px; border-radius: 12px; 
            color: #ccc; max-width: 420px; backdrop-filter: blur(8px); 
            align-self: center; text-align: center; 
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            transition: opacity 0.8s ease, transform 0.8s ease;
            opacity: 1; transform: translateY(0);
        }
        .controls.hidden { opacity: 0; transform: translateY(20px); pointer-events: none; }
        
        .upload-btn { background: linear-gradient(45deg, #d90429, #ef233c); border: 1px solid #ffca28; color: #fff; padding: 12px 24px; cursor: pointer; font-size: 1rem; margin-bottom: 15px; transition: 0.3s; text-transform: uppercase; letter-spacing: 2px; display: inline-block; border-radius: 4px; font-weight: bold; }
        .upload-btn:hover { background: #ffca28; color: #8a0303; box-shadow: 0 0 20px #ffca28; }
        #input-video { display: none; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 20; display: flex; justify-content: center; align-items: center; flex-direction: column; color: #ffca28; transition: opacity 1s; }
        .spinner { width: 50px; height: 50px; border: 4px solid transparent; border-top-color: #ffca28; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* ‰ªÖ‰øùÁïô‰∏≠ÂøÉÂçÅÂ≠óÂáÜÊòüÔºåÁßªÈô§ÈªÑËâ≤ÊâãÂäøÂÖâÊ†á */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 5;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255, 255, 255, 0.3);
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
    </style>
</head>
<body>
    <div id="loader"><div class="spinner"></div><div>SYSTEM INITIALIZING...</div><div style="font-size: 0.8rem; margin-top:10px; color:#777;">ËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ÊùÉÈôê / Please Allow Camera</div></div>
    <div id="crosshair"></div>
    <div id="ui-layer">
        <div class="header"><h1>Chroma Galaxy v73</h1><div class="status">STATE: <span id="state-display" style="color:#ff5555; font-weight:bold;">TREE</span></div></div>
        <div class="controls" id="controls-panel">
            <label class="upload-btn">Upload Photos<input type="file" id="file-input" multiple accept="image/*" style="display: none;"></label>
            <div style="margin-top:15px; font-size: 0.8rem;">
                <div>‚úä Fist: <b>To Tree</b> | üñêÔ∏è Open: <b>To Scatter</b></div>
                <div style="margin-top:5px; color:#aaa; font-size: 0.7rem;">(Tree Mode: Auto Rotate)</div>
                <div style="margin-top:10px; border-top:1px solid #555; padding-top:5px;">
                    <div>üëå Pinch: <b>Lock & Auto-Level</b></div>
                    <div>üñêÔ∏è Release: <b>Back (0.7s)</b></div>
                </div>
            </div>
        </div>
    </div>
    <video id="input-video"></video>

    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }</script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const CONFIG = {
            particleCount: 1600, 
            treeHeight: 32, treeRadius: 13, 
            scatterRadius: 25, 
            cameraZ: 55,
        };
        
        const STATE = { TREE: 'TREE', ZOOM: 'ZOOM', RETURNING: 'RETURNING', SCATTER: 'SCATTER' };
        let currentState = STATE.TREE; 
        
        // Input Signals
        let inputFist = false; let inputPinch = false; let inputOpen = false;
        
        let galaxyContainer = new THREE.Group(); 
        let targetQuaternion = new THREE.Quaternion(); 
        let currentQuaternion = new THREE.Quaternion(); 
        let startQuaternion = new THREE.Quaternion();
        let treeRotationY = 0; 

        // Core Data
        let sortedPhotoIndices = []; 
        let hoverMeshId = -1;      
        let lockedTargetId = -1;   
        let currentSortIndex = 0;   
        
        // Timers
        let returnStartTime = 0;      
        const RETURN_DURATION = 0.7; 
        const AUTO_PLAY_INTERVAL = 3.0; 
        const TOUR_MOVE_DURATION = 2.0;
        
        let lastAutoTime = 0;
        let transitionStartTime = 0;
        
        // Raycaster
        const raycaster = new THREE.Raycaster();
        const centerPoint = new THREE.Vector2(0, 0); 
        const tempVec = new THREE.Vector3();
        const tempParentInverse = new THREE.Quaternion();
        
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x050505); scene.fog = new THREE.FogExp2(0x050505, 0.008); 
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 0, CONFIG.cameraZ);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8; 
        document.body.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth/2, window.innerHeight/2), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.8; bloomPass.strength = 1.8; bloomPass.radius = 0.9;   
        const composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

        scene.add(new THREE.AmbientLight(0xffffff, 1.5)); 
        const dirLight = new THREE.DirectionalLight(0xffeeb1, 2.0); dirLight.position.set(0, 50, 30); scene.add(dirLight); 
        const plRed = new THREE.PointLight(0xff0000, 12, 100); plRed.position.set(-30, -10, 20); scene.add(plRed); 
        const plGreen = new THREE.PointLight(0x00ff00, 12, 100); plGreen.position.set(30, 10, 20); scene.add(plGreen); 
        const plGold = new THREE.PointLight(0xffd700, 8, 100); plGold.position.set(0, 0, 30); scene.add(plGold); 

        scene.add(galaxyContainer);

        let starMesh; function createStar() { 
            const starGeo = new THREE.OctahedronGeometry(1.5, 0); const starMat = new THREE.MeshStandardMaterial({ color: 0xfffacd, emissive: 0xfffacd, emissiveIntensity: 2.0, roughness: 0.1, metalness: 1.0 }); 
            starMesh = new THREE.Mesh(starGeo, starMat); starMesh.position.set(0, CONFIG.treeHeight / 2 + 1, 0); scene.add(starMesh); 
        } 
        createStar();

        const geometrySphere = new THREE.SphereGeometry(0.3, 16, 16); 
        const materialMatte = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.4, emissive: 0x000000, envMapIntensity: 1.0 });
        const materialMetal = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.15, metalness: 1.0, emissive: 0xffd700, emissiveIntensity: 1.3, envMapIntensity: 1.2 });
        new RGBELoader().setPath( 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/equirectangular/' ).load( 'royal_esplanade_1k.hdr', function ( texture ) { texture.mapping = THREE.EquirectangularReflectionMapping; materialMetal.envMap = texture; materialMatte.envMap = texture; materialMetal.needsUpdate = true; materialMatte.needsUpdate = true; });

        let imeshGold, imeshRed, imeshGreen;
        const particles = []; const dummy = new THREE.Object3D(); 
        let photoMeshes = [];

        function initParticles() {
            const count = CONFIG.particleCount;
            const goldGoal = Math.floor(count * 0.6); const redGoal = Math.floor(count * 0.3); const greenGoal = count - goldGoal - redGoal; 
            let goldCount = 0, redCount = 0, greenCount = 0;
            const types = [];
            for(let i=0; i<count; i++) { if (i < goldGoal) { types.push('gold'); goldCount++; } else if (i < goldGoal + redGoal) { types.push('red'); redCount++; } else { types.push('green'); greenCount++; } }
            types.sort(() => Math.random() - 0.5);
            imeshGold = new THREE.InstancedMesh(geometrySphere, materialMetal, goldCount);
            imeshRed = new THREE.InstancedMesh(geometrySphere, materialMatte, redCount);
            imeshGreen = new THREE.InstancedMesh(geometrySphere, materialMatte, greenCount);
            galaxyContainer.add(imeshGold); galaxyContainer.add(imeshRed); galaxyContainer.add(imeshGreen);
            imeshGold.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(goldCount * 3), 3);
            imeshRed.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(redCount * 3), 3);
            imeshGreen.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(greenCount * 3), 3);
            imeshGold.instanceMatrix.setUsage(THREE.DynamicDrawUsage); imeshRed.instanceMatrix.setUsage(THREE.DynamicDrawUsage); imeshGreen.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            let goldIdx = 0, redIdx = 0, greenIdx = 0;
            for (let i = 0; i < count; i++) {
                const v = Math.random(); const progress = Math.pow(v, 1/1.8); 
                const h = (CONFIG.treeHeight / 2) - (progress * CONFIG.treeHeight);
                const rMax = progress * CONFIG.treeRadius; const rTree = rMax * Math.sqrt(Math.random()); const thetaTree = Math.random() * Math.PI * 2;
                const rScatter = CONFIG.scatterRadius * Math.cbrt(Math.random()); const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                
                const type = types[i]; let colorHex = (type === 'gold') ? 0xffd700 : (type === 'red' ? 0xff2222 : 0x44ff44);
                const color = new THREE.Color(colorHex); let baseScale = 1.0; 
                const pData = { 
                    id: i, type: type,
                    pos: new THREE.Vector3(rTree * Math.cos(thetaTree), h, rTree * Math.sin(thetaTree)), 
                    targetTree: new THREE.Vector3(rTree * Math.cos(thetaTree), h, rTree * Math.sin(thetaTree)), 
                    targetScatter: new THREE.Vector3(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi)), 
                    rot: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0), 
                    scale: baseScale, baseColor: color.clone(), twinkleSpeed: 0.5 + Math.random() * 2.0, twinklePhase: Math.random() * Math.PI * 2
                };
                dummy.position.copy(pData.pos); dummy.scale.setScalar(baseScale); dummy.rotation.copy(pData.rot); dummy.updateMatrix();
                if (type === 'gold') { imeshGold.setColorAt(goldIdx, color); imeshGold.setMatrixAt(goldIdx++, dummy.matrix); } 
                else if (type === 'red') { imeshRed.setColorAt(redIdx, color); imeshRed.setMatrixAt(redIdx++, dummy.matrix); } 
                else { imeshGreen.setColorAt(greenIdx, color); imeshGreen.setMatrixAt(greenIdx++, dummy.matrix); }
                particles.push(pData);
            }
        }
        initParticles();

        let haloMesh; const haloParticles = [];
        function initRealHalo() {
            const count = 1000; const geo = new THREE.SphereGeometry(0.1, 8, 8); const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2.5, roughness: 1.0 });
            haloMesh = new THREE.InstancedMesh(geo, mat, count); haloMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            for(let i=0; i<count; i++) {
                const r = CONFIG.scatterRadius * (1.3 + Math.random() * 0.8); const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                const pos = new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                haloParticles.push({ pos: pos, phase: Math.random() * Math.PI * 2, speed: 1 + Math.random() * 2 });
            }
            galaxyContainer.add(haloMesh);
        }
        initRealHalo();

        let bgStars; 
        function initBackgroundStars() { 
            const starCount = 3000; 
            const bgGeo = new THREE.BufferGeometry(); 
            const positions = []; 
            for(let i=0; i<starCount; i++) { 
                const r = 60 + Math.random() * 140; 
                const theta = Math.random() * Math.PI * 2; 
                const phi = Math.acos(2 * Math.random() - 1); 
                positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)); 
            } 
            bgGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); 
            bgStars = new THREE.Points(bgGeo, new THREE.PointsMaterial({ 
                color: 0xffffff, size: 0.6, transparent: true, opacity: 0, fog: false 
            })); 
            scene.add(bgStars); 
        } 
        initBackgroundStars();

        const photoGroup = new THREE.Group(); 
        galaxyContainer.add(photoGroup); 
        
        document.getElementById('file-input').addEventListener('change', handleUpload);
        
        function handleUpload(e) {
            const files = e.target.files; if (!files.length) return; photoGroup.clear(); photoMeshes = [];
            sortedPhotoIndices = []; hoverMeshId = -1; lockedTargetId = -1;
            
            const numFiles = files.length; const goldenRatio = (1 + Math.sqrt(5)) / 2; const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image(); 
                    img.src = event.target.result; 
                    img.onload = function() {
                        const texture = new THREE.TextureLoader().load(img.src); 
                        const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, color: 0xbbbbbb }); 
                        
                        const aspect = img.width / img.height;
                        const BASE_SIZE = 5;
                        let w = BASE_SIZE; let h = BASE_SIZE;
                        if (aspect > 1) { h = BASE_SIZE / aspect; } else { w = BASE_SIZE * aspect; }

                        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat); 
                        
                        const i = index; 
                        const t = index / numFiles; const hTree = t * (CONFIG.treeHeight / 2) * 0.9; 
                        const heightFraction = (hTree + CONFIG.treeHeight / 2) / CONFIG.treeHeight;
                        const rAtHeight = CONFIG.treeRadius * (1 - heightFraction);
                        const rFinal = rAtHeight * 1.05;
                        const thetaSpiral = index * goldenAngle;
                        mesh.userData.originalPos = new THREE.Vector3(rFinal * Math.cos(thetaSpiral), hTree, rFinal * Math.sin(thetaSpiral));
                        
                        const yBase = 1 - (i / (numFiles - 1)) * 2; const radiusAtYBase = Math.sqrt(1 - yBase * yBase); 
                        const thetaBase = 2 * Math.PI * i / goldenRatio;
                        const depthVar = 0.6 + 0.4 * Math.random(); 
                        const currentR = CONFIG.scatterRadius * depthVar;
                        const x = currentR * radiusAtYBase * Math.cos(thetaBase); const yPos = currentR * yBase; const z = currentR * radiusAtYBase * Math.sin(thetaBase);
                        
                        mesh.userData.id = index;
                        mesh.userData.scatterPos = new THREE.Vector3(x, yPos, z);
                        mesh.position.copy(mesh.userData.scatterPos); 
                        mesh.lookAt(0,0,0); mesh.rotateY(Math.PI);
                        mesh.userData.baseRotation = mesh.rotation.clone();
                        mesh.userData.treeScale = (0.15 + Math.random() * 0.10) * 2.0 * 1.5; 
                        
                        const border = new THREE.Mesh(new THREE.BoxGeometry(w + 0.2, h + 0.2, 0.1), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 1.0 })); 
                        border.position.z = -0.06; border.name = "border"; mesh.add(border); 
                        
                        photoGroup.add(mesh); photoMeshes.push(mesh);
                        
                        if (photoMeshes.length === numFiles) {
                            photoMeshes.sort((a, b) => a.userData.id - b.userData.id);
                            buildGreedyPath(); 
                        }
                    };
                }; reader.readAsDataURL(file);
            }); 
            currentState = STATE.TREE; 
        }

        function buildGreedyPath() {
            if (photoMeshes.length === 0) return;
            const visited = new Set();
            let currentIdx = 0; 
            sortedPhotoIndices = [0]; visited.add(0);
            while (sortedPhotoIndices.length < photoMeshes.length) {
                let nearestId = -1; let minDist = Infinity;
                const currentPos = photoMeshes[currentIdx].userData.scatterPos;
                for (let i = 0; i < photoMeshes.length; i++) {
                    if (visited.has(i)) continue;
                    const dist = currentPos.distanceToSquared(photoMeshes[i].userData.scatterPos);
                    if (dist < minDist) { minDist = dist; nearestId = i; }
                }
                if (nearestId !== -1) { sortedPhotoIndices.push(nearestId); visited.add(nearestId); currentIdx = nearestId; } else break;
            }
            currentSortIndex = 0;
            triggerRotationTo(sortedPhotoIndices[0]);
            lastAutoTime = clock.getElapsedTime();
        }

        function triggerRotationTo(targetId) {
            const targetMesh = photoMeshes[targetId];
            if (targetMesh) {
                startQuaternion.copy(currentQuaternion);
                const targetDir = targetMesh.userData.scatterPos.clone().normalize();
                if (targetDir.lengthSq() > 0.001) {
                    targetQuaternion.setFromUnitVectors(targetDir, new THREE.Vector3(0, 0, 1));
                }
                transitionStartTime = clock.getElapsedTime();
            }
        }

        function updateRaycaster() {
            if (currentState === STATE.TREE) {
                hoverMeshId = -1; return;
            }
            raycaster.setFromCamera(centerPoint, camera);
            const intersects = raycaster.intersectObjects(photoGroup.children, true);
            if (intersects.length > 0) {
                let hitObj = intersects[0].object;
                while(hitObj && hitObj.userData.id === undefined) {
                    hitObj = hitObj.parent;
                }
                if (hitObj && hitObj.userData.id !== undefined) {
                    hoverMeshId = hitObj.userData.id;
                } else {
                    hoverMeshId = -1;
                }
            } else {
                hoverMeshId = -1;
            }
        }

        const clock = new THREE.Clock(); 

        function updateState(time) {
            if (inputFist) {
                currentState = STATE.TREE;
                lastAutoTime = time;
            } else if (inputOpen && currentState === STATE.TREE) {
                currentState = STATE.SCATTER;
                lastAutoTime = time;
                triggerRotationTo(sortedPhotoIndices[currentSortIndex]);
            }

            if (currentState !== STATE.TREE) {
                if (inputPinch) {
                    if (currentState !== STATE.ZOOM) {
                        let targetId = hoverMeshId;
                        if (targetId === -1 && sortedPhotoIndices.length > 0) {
                            targetId = sortedPhotoIndices[currentSortIndex];
                        }
                        if (targetId !== -1) {
                            lockedTargetId = targetId;
                            const idx = sortedPhotoIndices.indexOf(targetId);
                            if (idx !== -1) currentSortIndex = idx;
                        }
                    }
                    currentState = STATE.ZOOM;
                    lastAutoTime = time; 
                    
                } else if (currentState === STATE.ZOOM) {
                    currentState = STATE.RETURNING;
                    returnStartTime = time;
                    lastAutoTime = time;
                } else if (currentState === STATE.RETURNING) {
                    if (time - returnStartTime > RETURN_DURATION) {
                        currentState = STATE.SCATTER;
                        if (sortedPhotoIndices.length > 0) {
                            currentSortIndex = (currentSortIndex + 1) % sortedPhotoIndices.length;
                            triggerRotationTo(sortedPhotoIndices[currentSortIndex]);
                        }
                        lockedTargetId = -1;
                        lastAutoTime = time;
                    } else {
                        lastAutoTime = time; 
                    }
                } else {
                    currentState = STATE.SCATTER;
                    if (sortedPhotoIndices.length > 0 && time - transitionStartTime > (TOUR_MOVE_DURATION + AUTO_PLAY_INTERVAL)) {
                        currentSortIndex = (currentSortIndex + 1) % sortedPhotoIndices.length;
                        triggerRotationTo(sortedPhotoIndices[currentSortIndex]);
                        lastAutoTime = time;
                    }
                }
            }
        }

        function updateCameraRotation(dt, time) {
            if (currentState === STATE.TREE) {
                const identityQ = new THREE.Quaternion();
                currentQuaternion.slerp(identityQ, dt * 2.0);
                galaxyContainer.quaternion.copy(currentQuaternion);
                treeRotationY += dt * 0.15; 

            } else if (currentState === STATE.SCATTER) {
                let t = (time - transitionStartTime) / TOUR_MOVE_DURATION;
                t = Math.min(Math.max(t, 0), 1);
                t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                currentQuaternion.slerpQuaternions(startQuaternion, targetQuaternion, t);
                galaxyContainer.quaternion.copy(currentQuaternion);

            } else {
                let lookAtTargetId = lockedTargetId;
                if (lookAtTargetId !== -1) {
                    const targetMesh = photoMeshes[lookAtTargetId];
                    if (targetMesh) {
                        const stablePos = targetMesh.userData.scatterPos.clone().normalize();
                        targetQuaternion.setFromUnitVectors(stablePos, new THREE.Vector3(0, 0, 1));
                    }
                }
                
                let lerpSpeed = (currentState === STATE.ZOOM) ? 10.0 : 5.0;
                currentQuaternion.slerp(targetQuaternion, dt * lerpSpeed);
                galaxyContainer.quaternion.copy(currentQuaternion);
            }
        }

        const flipY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

        function render() { 
            requestAnimationFrame(render); 
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            updateRaycaster();
            updateState(time);
            updateCameraRotation(dt, time);

            let statusText = currentState;
            if (currentState === STATE.RETURNING) statusText = "WAITING...";
            document.getElementById('state-display').innerText = statusText;
            const controls = document.getElementById('controls-panel');
            if (currentState === STATE.SCATTER || currentState === STATE.ZOOM || currentState === STATE.RETURNING) controls.classList.add('hidden'); else controls.classList.remove('hidden');

            starMesh.position.lerp(new THREE.Vector3(0, currentState === STATE.TREE ? CONFIG.treeHeight / 2 + 1 : CONFIG.treeHeight / 2 + 12 + Math.sin(time)*2, 0), dt * 2); 
            starMesh.rotation.y += dt * 0.5;
            bgStars.material.opacity = THREE.MathUtils.lerp(bgStars.material.opacity, 1.0, dt * 1); 

            const haloScaleBase = currentState === STATE.TREE ? 0 : 1; 
            haloParticles.forEach((hp, i) => {
                dummy.position.copy(hp.pos); const breath = 1 + Math.sin(time * hp.speed + hp.phase) * 0.3;
                dummy.scale.setScalar(haloScaleBase * breath); dummy.lookAt(camera.position); dummy.updateMatrix(); haloMesh.setMatrixAt(i, dummy.matrix);
            });
            haloMesh.instanceMatrix.needsUpdate = true;

            let goldIdx = 0; let redIdx = 0; let greenIdx = 0; const tempColor = new THREE.Color();
            particles.forEach((p, i) => {
                let target = p.targetTree; 
                if (currentState === STATE.TREE) { target = p.targetTree.clone().applyAxisAngle(new THREE.Vector3(0,1,0), treeRotationY); } 
                else { target = p.targetScatter; }
                p.pos.lerp(target, dt * 2.0); dummy.position.copy(p.pos);
                let currentScale = p.scale;
                const noise = Math.sin(time * p.twinkleSpeed + p.twinklePhase);
                let brightnessMultiplier = 1.0; if (noise > 0.97) brightnessMultiplier = 1.0 + (noise - 0.97) * 200.0; 
                tempColor.copy(p.baseColor).multiplyScalar(brightnessMultiplier);
                if (p.type === 'gold') { const scaleOscillation = currentState === STATE.TREE ? 0.05 : 0.2; currentScale *= (1 + Math.sin(time * 3 + p.id) * scaleOscillation); }
                dummy.scale.setScalar(currentScale); dummy.rotation.set(p.rot.x + time*0.5, p.rot.y + time*0.3, p.rot.z); dummy.updateMatrix();
                if (p.type === 'gold') { imeshGold.setMatrixAt(goldIdx, dummy.matrix); imeshGold.setColorAt(goldIdx++, tempColor); } 
                else if (p.type === 'red') { imeshRed.setMatrixAt(redIdx, dummy.matrix); imeshRed.setColorAt(redIdx++, tempColor); } 
                else { imeshGreen.setMatrixAt(greenIdx, dummy.matrix); imeshGreen.setColorAt(greenIdx++, tempColor); }
            });
            imeshGold.instanceMatrix.needsUpdate = true; imeshRed.instanceMatrix.needsUpdate = true; imeshGreen.instanceMatrix.needsUpdate = true;
            imeshGold.instanceColor.needsUpdate = true; imeshRed.instanceColor.needsUpdate = true; imeshGreen.instanceColor.needsUpdate = true;

            photoMeshes.forEach(mesh => {
                const border = mesh.getObjectByName("border");
                const targetQ = new THREE.Quaternion();

                if (currentState === STATE.TREE) { 
                    let target = mesh.userData.originalPos.clone().applyAxisAngle(new THREE.Vector3(0,1,0), treeRotationY);
                    mesh.position.lerp(target, dt * 2); 
                    mesh.lookAt(new THREE.Vector3(0, mesh.position.y, 0)); mesh.rotateY(Math.PI); 
                    const s = mesh.userData.treeScale; mesh.scale.lerp(new THREE.Vector3(s, s, s), dt * 3); 
                    border.material.emissiveIntensity = 0.5;
                    mesh.quaternion.slerp(mesh.quaternion, dt * 5); 
                } else {
                    mesh.scale.lerp(new THREE.Vector3(1,1,1), dt * 3); 
                    
                    if (currentState === STATE.ZOOM && mesh.userData.id === lockedTargetId) {
                        const zoomTarget = mesh.userData.scatterPos.clone().normalize().multiplyScalar(40);
                        mesh.position.lerp(zoomTarget, dt * 5);
                        mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), dt * 5);
                        border.material.emissive.setHex(0xff3333); border.material.emissiveIntensity = 4.0;
                        
                        mesh.getWorldPosition(tempVec);
                        dummy.position.copy(tempVec);
                        dummy.lookAt(camera.position);
                        tempParentInverse.copy(galaxyContainer.quaternion).invert();
                        targetQ.copy(tempParentInverse).multiply(dummy.quaternion);

                    } else {
                        mesh.position.lerp(mesh.userData.scatterPos, dt * 3);
                        targetQ.setFromEuler(mesh.userData.baseRotation);

                        let isHighlight = false;
                        if (currentState === STATE.RETURNING && mesh.userData.id === lockedTargetId) isHighlight = true;
                        if (currentState === STATE.SCATTER && sortedPhotoIndices.length > 0 && mesh.userData.id === sortedPhotoIndices[currentSortIndex]) isHighlight = true;
                        if (currentState === STATE.SCATTER && mesh.userData.id === hoverMeshId) isHighlight = true;

                        if (isHighlight) {
                            mesh.scale.lerp(new THREE.Vector3(1.3, 1.3, 1.3), dt * 5);
                            border.material.emissive.setHex(0xffd700); border.material.emissiveIntensity = 2.0;
                        } else {
                            mesh.scale.lerp(new THREE.Vector3(1.0, 1.0, 1.0), dt * 5);
                            border.material.emissive.setHex(0xffd700); border.material.emissiveIntensity = 0.5;
                        }
                    }
                    mesh.quaternion.slerp(targetQ, dt * 8); 
                }
            });
            composer.render();
        }
        render();

        const videoElement = document.getElementById('input-video');
        
        function onResults(results) {
            document.getElementById('loader').style.opacity = 0; setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0]; 
                const wrist = landmarks[0]; let avgDist = 0; 
                [8, 12, 16, 20].forEach(id => avgDist += Math.sqrt(Math.pow(landmarks[id].x - wrist.x, 2) + Math.pow(landmarks[id].y - wrist.y, 2)));
                
                inputFist = (avgDist / 4) < 0.22; 
                inputPinch = Math.sqrt(Math.pow(landmarks[8].x - landmarks[4].x, 2) + Math.pow(landmarks[8].y - landmarks[4].y, 2)) < 0.10; 
                inputOpen = (avgDist / 4) > 0.35; 
            } else { 
                inputFist = false; inputPinch = false; inputOpen = false;
            }
        }
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 }); hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 }); cameraUtils.start();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
